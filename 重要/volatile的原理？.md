## 结论
volatile 能保证可见性和有序性，不能保证原子性

## volatile 如何保证可见性和有序性？

当一个共享变量被 volatile 修饰时：
1. **它会保证修改的值会立即被更新到主存**
2. **当有其他线程需要读取时，它会去主存中读取新值**。保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
3. **禁止进行指令重排序**。


## volatile的实现原理
#### 1.可见性
处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内存的数据独到内部缓存后再进行操作，但操作完后不知什么时候会写到内存。如果对声明了 volatile 变量进行写操作时，**JVM **会向**处理器**发送一条 **Lock 前缀的指令**，将这个变量所在缓存行的数据写会到系统内存。 **这一步确保了如果有其他线程对声明了 volatile 变量进行修改，则立即更新主内存中数据**。但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理会通过嗅探在总线上传播的数据来检查自己的缓存是否过期， 当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据读到处理器缓存里。 这一步确保了其他线程获得的声明了 volatile 变量都是从主内存中获取最新的。
#### 2. 有序性
Lock 前缀指令实际上相当于一个**内存屏障**（也成内存栅栏），**它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置**，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。

## 链接

[Github：volatile](https://github.com/LRH1993/android_interview/blob/master/java/concurrence/volatile.md)
[博客园：为什么volatile不能保证原子性而Atomic可以？（从编译的角度来看）](https://www.cnblogs.com/mainz/p/3556430.html)