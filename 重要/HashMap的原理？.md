## 原理
HashMap是通过<u>对key的hash值进行转换</u>来定位每个key在内部数组上的位置。HashMap是实现原理是**数组+链表**，1.8以后加入了**红黑树**。

## Key的Hash值计算

第一步：<u>正常计算出key的hash值</u>（调用key的hashCode()方法，如果key是null则其hash值是0）；
第二步：<u>对得到的hash值进行扰乱</u>，目的是为了让hash值能尽可能的均匀分布。


## 问题

#### 1. 为什么不直接使用key而要使用key的hash值？
答：如果直接使用key，那么在查找的时候需要调用key的equals方法去逐个比较，时间复杂度从原本的O(1)变成了O(n)，且equals()比较的效率也很低，而通过hash值可以直接定位到桶。

#### 2. 那为什么又不直接用hash值作为数组上的索引？
答：为了防止数组下标越界，因为hash值不确定性，很容易越界。

#### 3. 那为什么用的是(n - 1) & hash，而不是hash % n呐？
答：其实早期版本就是用hash % n，但是为了追求效率，后来就改成了位运算(n - 1) & hash（位运速度比取余算快（注意：%是取余不是取模））。
<u>当n为2的指数，(n - 1) & hash 与 hash % n是等价的</u>

#### 4. 为什么(n - 1) & hash和hash % n是等价的？
答：这里利用了HashMap的一个特性：HashMap规定其容量必须是2的n次方（最大为230次方）,那么n肯定就是2xx次方了，用二进制表示就是1000...00，最前面是1，后面全是0(假设有k个0)，那么n-1就全变成1了111...1111（k-1个1），hash ^ (n - 1)得到的最大值就是n-1，最小值是0。效果和hash % n一样，只是改为位运算了。位运算比取模运算更快。

#### 5. 为什么HashMap的容量是2的幂次方
答：是为了hash值的计算，早期版本的hash值计算是hash % n，来得到一个数组范围内的hash值，而当容量为2的幂次方（其二进制永远是100.....，再减去1，就是全部都是11111，方便做与运算），通过(n - 1) & hash来计算哈希值，会更加效率。


## 链接

[CSDN：Java（Android）数据结构汇总（四）-- Map（上）](https://www.jianshu.com/p/4c9576780588)